# 시스템 작동 흐름 상세 분석

## 📋 전체 실행 흐름

```
┌─────────────────────────────────────────────────────────────┐
│                    프로그램 시작                             │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                1단계: 초기화 (Initialization)               │
├─────────────────────────────────────────────────────────────┤
│ 1-1. config.yaml 로드                                       │
│ 1-2. 스테레오 캘리브레이션 데이터 로드                      │
│      (data/stereo_calibration.pkl)                          │
│ 1-3. 카메라 인식 범위 계산 (좌표평면)                      │
│ 1-4. 가상 그래프 객체 생성 (방정식 없음)                   │
│ 1-5. 사용자 방정식 선택 입력                                │
│ 1-6. 방정식 → 3D 그래프 점 생성                            │
│ 1-7. 양쪽 카메라 초기화 (640x480)                          │
│ 1-8. 3D 손 추적기 초기화 (Mediapipe, 단일 손)              │
│ 1-9. 진동모터 컨트롤러 초기화 (GPIO 18번)                  │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│              2단계: 메인 루프 (Real-time Loop)              │
└─────────────────────────────────────────────────────────────┘
    ┌───────────────────────────────────────────────┐
    │  while True:                                   │
    │                                                 │
    │  ┌──────────────────────────────────────┐    │
    │  │  2-1. 프레임 캡처                     │    │
    │  │  - 왼쪽 카메라에서 프레임 읽기        │    │
    │  │  - 오른쪽 카메라에서 프레임 읽기      │    │
    │  └──────────────────────────────────────┘    │
    │               ↓                                 │
    │  ┌──────────────────────────────────────┐    │
    │  │  2-2. 3D 손 추적                      │    │
    │  │  HandTracker3D.process_frame()        │    │
    │  │  ├─ 이미지 rectify (왜곡 보정)        │    │
    │  │  ├─ Mediapipe로 손 랜드마크 감지      │    │
    │  │  │   (각 카메라에서 21개 관절)         │    │
    │  │  ├─ 양쪽 카메라에서 같은 손 매칭      │    │
    │  │  └─ 스테레오 삼각측량으로 3D 좌표 계산│    │
    │  │      → [(x,y,z), ...] 21개 점         │    │
    │  └──────────────────────────────────────┘    │
    │               ↓                                 │
    │  ┌──────────────────────────────────────┐    │
    │  │  2-3. 햅틱 피드백 조건 판단            │    │
    │  │                                        │    │
    │  │  if 손이 감지됨:                       │    │
    │  │    ├─ 검지손가락 끝 좌표 추출 (idx=8) │    │
    │  │    │   index_tip = (x, y, z)          │    │
    │  │    │                                   │    │
    │  │    ├─ 조건1: 테이블 접촉?             │    │
    │  │    │   if y >= 200mm:                 │    │
    │  │    │                                   │    │
    │  │    └─ 조건2: 그래프 접촉?             │    │
    │  │        if distance_to_graph <= 30mm:  │    │
    │  │          should_vibrate = True         │    │
    │  └──────────────────────────────────────┘    │
    │               ↓                                 │
    │  ┌──────────────────────────────────────┐    │
    │  │  2-4. 진동모터 제어                    │    │
    │  │                                        │    │
    │  │  if should_vibrate and not vibrating:  │    │
    │  │    motor.start_all(intensity=80%)      │    │
    │  │    vibrating = True                    │    │
    │  │                                        │    │
    │  │  elif not should_vibrate and vibrating:│    │
    │  │    motor.stop_all()                    │    │
    │  │    vibrating = False                   │    │
    │  └──────────────────────────────────────┘    │
    │               ↓                                 │
    │  ┌──────────────────────────────────────┐    │
    │  │  2-5. 화면 표시                        │    │
    │  │  - FPS, 방정식, 좌표, 상태 표시        │    │
    │  │  - 손 랜드마크 시각화                  │    │
    │  │  - 왼쪽/오른쪽 프레임 병합 표시        │    │
    │  └──────────────────────────────────────┘    │
    │               ↓                                 │
    │  ┌──────────────────────────────────────┐    │
    │  │  2-6. 키보드 입력 처리                 │    │
    │  │  - ESC: 루프 종료                      │    │
    │  │  - 0~5: 방정식 변경                    │    │
    │  └──────────────────────────────────────┘    │
    │               ↓                                 │
    └───────────────┬───────────────────────────────┘
                    │
                    ↓
┌─────────────────────────────────────────────────────────────┐
│                3단계: 종료 (Cleanup)                         │
├─────────────────────────────────────────────────────────────┤
│ 3-1. 진동모터 정지 및 GPIO 정리                             │
│ 3-2. 손 추적기 종료 (Mediapipe 리소스 해제)                │
│ 3-3. 카메라 해제                                            │
│ 3-4. OpenCV 윈도우 종료                                     │
└─────────────────────────────────────────────────────────────┘
                            ↓
                     프로그램 종료
```

---

## 🔍 핵심 모듈별 상세 흐름

### A. 방정식 → 3D 그래프 변환

```python
# VirtualGraph 클래스

입력: y = f(x), x_range=(-300, 300)
      ↓
┌──────────────────────────────────────┐
│ _generate_graph_from_equation()      │
├──────────────────────────────────────┤
│ 1. x 값을 100개 생성                 │
│    x = [-300, -294, ..., 294, 300]  │
│                                       │
│ 2. 각 x에 대해 y = f(x) 계산        │
│    예: f(x) = x²/100                 │
│                                       │
│ 3. 3D 좌표 생성                      │
│    for x in x_values:                │
│      y_value = f(x)                  │
│      point = (x, 200, 400+y_value)   │
│      graph_points.append(point)      │
│                                       │
│ 4. numpy 배열로 변환                 │
│    shape: (100, 3)                   │
└──────────────────────────────────────┘
      ↓
출력: [(x₁,200,z₁), (x₂,200,z₂), ..., (x₁₀₀,200,z₁₀₀)]
```

**예시: y = x²/100**
```
x = -200 → y = 40000/100 = 400 → (x=-200, y=200, z=800)
x = -100 → y = 10000/100 = 100 → (x=-100, y=200, z=500)
x = 0    → y = 0              → (x=0,    y=200, z=400)
x = 100  → y = 10000/100 = 100 → (x=100,  y=200, z=500)
x = 200  → y = 40000/100 = 400 → (x=200,  y=200, z=800)

결과: 테이블 위 포물선 형태
```

---

### B. 3D 손 추적 프로세스

```python
# HandTracker3D.process_frame()

입력: frame_left, frame_right (640x480 BGR 이미지)
      ↓
┌─────────────────────────────────────────────┐
│ 1. 이미지 전처리                             │
├─────────────────────────────────────────────┤
│ stereo_calib.rectify_images()               │
│ - 왜곡 제거 (distortion correction)         │
│ - 에피폴라 정렬 (epipolar rectification)    │
│ - 두 이미지의 y축 정렬 (같은 높이 = 같은 y) │
└─────────────────────────────────────────────┘
      ↓
┌─────────────────────────────────────────────┐
│ 2. Mediapipe 손 감지                        │
├─────────────────────────────────────────────┤
│ rgb_left = cv2.cvtColor(rect_left, RGB)     │
│ rgb_right = cv2.cvtColor(rect_right, RGB)   │
│                                              │
│ results_left = hands_left.process(rgb_left) │
│ results_right = hands_right.process(...)    │
│                                              │
│ 출력 (각 카메라):                            │
│ - multi_hand_landmarks: 21개 관절 2D 좌표   │
│ - multi_handedness: 'Left' or 'Right'       │
└─────────────────────────────────────────────┘
      ↓
┌─────────────────────────────────────────────┐
│ 3. 양쪽 카메라에서 같은 손 매칭              │
├─────────────────────────────────────────────┤
│ _find_matching_hand()                       │
│                                              │
│ 기준: 손목(WRIST, idx=0)의 y 좌표 비교      │
│ if |wrist_y_left - wrist_y_right| < 0.1:   │
│   → 같은 손으로 판단                        │
└─────────────────────────────────────────────┘
      ↓
┌─────────────────────────────────────────────┐
│ 4. 스테레오 삼각측량 (Triangulation)        │
├─────────────────────────────────────────────┤
│ _triangulate_landmarks()                    │
│                                              │
│ for 각 관절(21개):                           │
│   x_left = landmark_left.x * width          │
│   x_right = landmark_right.x * width        │
│   y = landmark_left.y * height              │
│                                              │
│   disparity = x_left - x_right              │
│                                              │
│   # Q 행렬로 3D 변환                         │
│   point_3d = perspectiveTransform(          │
│     [x_left, y, disparity], Q               │
│   )                                          │
│                                              │
│   # 동차좌표 → 일반좌표                      │
│   (x, y, z) = point_3d / point_3d[3]        │
└─────────────────────────────────────────────┘
      ↓
출력: hands_3d = [
  {
    'handedness': 'Left',
    'landmarks_3d': [
      (x₀, y₀, z₀),  # WRIST
      (x₁, y₁, z₁),  # THUMB_CMC
      ...
      (x₈, y₈, z₈),  # INDEX_FINGER_TIP ← 중요!
      ...
      (x₂₀, y₂₀, z₂₀) # PINKY_TIP
    ],
    'confidence': 0.95
  }
]
```

**Mediapipe 손 랜드마크 인덱스:**
```
     8: INDEX_FINGER_TIP (검지 끝)
     ^
     |
     7: INDEX_FINGER_DIP
     |
     6: INDEX_FINGER_PIP
     |
     5: INDEX_FINGER_MCP
    /
   /
  0: WRIST (손목)
```

---

### C. 햅틱 피드백 판단 로직

```python
# main.py 메인 루프 내부

hands_3d = [...] from HandTracker3D
      ↓
┌─────────────────────────────────────────┐
│ 1. 손 존재 여부 확인                     │
├─────────────────────────────────────────┤
│ if not hands_3d:                        │
│   should_vibrate = False                │
│   continue                               │
└─────────────────────────────────────────┘
      ↓
┌─────────────────────────────────────────┐
│ 2. 검지손가락 끝 좌표 추출               │
├─────────────────────────────────────────┤
│ hand_data = hands_3d[0]                 │
│ index_tip = hand_data['landmarks_3d'][8]│
│ index_tip = (x, y, z)  # mm 단위        │
└─────────────────────────────────────────┘
      ↓
┌─────────────────────────────────────────┐
│ 3. 조건 1: 테이블 접촉 확인              │
├─────────────────────────────────────────┤
│ index_height = index_tip[1]  # y 좌표   │
│                                          │
│ if index_height < TABLE_HEIGHT (200mm): │
│   → 손가락이 테이블 위 공중에 있음       │
│   → should_vibrate = False               │
│   → 종료                                 │
└─────────────────────────────────────────┘
      ↓ (y >= 200mm)
┌─────────────────────────────────────────┐
│ 4. 조건 2: 그래프 접촉 확인              │
├─────────────────────────────────────────┤
│ if len(virtual_graph.graph_points) == 0:│
│   → 그래프 없음                          │
│   → should_vibrate = False               │
│   → 종료                                 │
│                                          │
│ distance = virtual_graph.distance_to_   │
│            graph(index_tip)              │
│                                          │
│ if distance <= thickness (30mm):        │
│   → 그래프에 닿았음!                     │
│   → should_vibrate = True                │
│ else:                                    │
│   → should_vibrate = False               │
└─────────────────────────────────────────┘
      ↓
┌─────────────────────────────────────────┐
│ 5. 진동 상태 업데이트                    │
├─────────────────────────────────────────┤
│ if should_vibrate and not vibrating:    │
│   motor_controller.start_all(80%)       │
│   vibrating = True                       │
│   log("진동 시작!")                      │
│                                          │
│ elif not should_vibrate and vibrating:  │
│   motor_controller.stop_all()           │
│   vibrating = False                      │
│   log("진동 정지")                       │
└─────────────────────────────────────────┘
```

**거리 계산 상세:**
```python
# VirtualGraph.distance_to_graph()

점: P = (px, py, pz)
그래프: 선분들의 집합

for 각 선분 (A, B):
  ├─ 벡터 AB = B - A
  ├─ 벡터 AP = P - A
  ├─ t = (AP·AB) / |AB|²  # 투영 비율
  ├─ t = clamp(t, 0, 1)   # 선분 범위로 제한
  ├─ 투영점 = A + t * AB
  └─ 거리 = |P - 투영점|

최소 거리 반환
```

---

## 🎮 실시간 상호작용 흐름

### 사용자 시나리오

```
시간축 →

t=0s:  프로그램 시작
       ↓
t=3s:  방정식 "1" 입력 (y=x²/100)
       → 그래프 100개 점 생성
       ↓
t=5s:  카메라 앞에 손 위치
       → Mediapipe 감지 시작
       ↓
t=7s:  손을 테이블 쪽으로 내림
       ┌──────────────────────────────┐
       │ y = 150mm (공중)              │
       │ 상태: ABOVE TABLE             │
       │ 진동: Off                     │
       └──────────────────────────────┘
       ↓
t=9s:  손가락이 테이블 접촉
       ┌──────────────────────────────┐
       │ y = 205mm (테이블)            │
       │ x = -50mm, z = 420mm          │
       │ 상태: ON TABLE                │
       │ 그래프까지 거리: 45mm         │
       │ 진동: Off                     │
       └──────────────────────────────┘
       ↓
t=11s: 손가락을 그래프 방향으로 이동
       ┌──────────────────────────────┐
       │ x = -100mm, z = 480mm         │
       │ 그래프까지 거리: 22mm         │
       │ 22mm < 30mm (threshold)       │
       │ 진동: ON! ████████            │
       │ log: "진동 시작!"             │
       └──────────────────────────────┘
       ↓
t=13s: 손가락을 그래프 선을 따라 이동
       ┌──────────────────────────────┐
       │ x = -80mm → -60mm → -40mm     │
       │ 그래프를 따라 이동 중         │
       │ 거리: 18mm → 25mm → 12mm      │
       │ 진동: ON (계속 유지)          │
       └──────────────────────────────┘
       ↓
t=15s: 손가락이 그래프에서 벗어남
       ┌──────────────────────────────┐
       │ x = 0mm, z = 350mm            │
       │ 그래프까지 거리: 55mm         │
       │ 55mm > 30mm                   │
       │ 진동: OFF                     │
       │ log: "진동 정지"              │
       └──────────────────────────────┘
       ↓
t=17s: 키보드 "2" 누름
       → 방정식 변경: y=sin(x/50)*100
       → 그래프 재생성 (100개 점)
       ↓
t=19s: 새로운 그래프 탐색...
       └→ 반복
```

---

## 🔄 데이터 흐름도

```
┌─────────────┐
│   카메라    │ (하드웨어)
│  Left/Right │
└──────┬──────┘
       │ 640x480 BGR 이미지
       ↓
┌─────────────────────┐
│ StereoCalibration   │ (모듈)
│ - rectify_images()  │
└──────┬──────────────┘
       │ Rectified 이미지
       ↓
┌─────────────────────┐
│  HandTracker3D      │ (모듈)
│  - Mediapipe        │
│  - Triangulation    │
└──────┬──────────────┘
       │ hands_3d: [{landmarks_3d, ...}]
       ↓
┌─────────────────────┐
│   main.py           │ (로직)
│   - 검지 추출       │
│   - 테이블 확인     │
│   - 그래프 충돌     │
└──────┬──────────────┘
       │ should_vibrate: True/False
       ↓
┌─────────────────────────┐
│ VibrationMotorController│ (모듈)
│ - start_all() / stop()  │
└──────┬──────────────────┘
       │ GPIO 신호
       ↓
┌─────────────┐
│ 진동모터    │ (하드웨어)
│  GPIO 18    │
└─────────────┘
```

---

## 📊 성능 특성

### 처리 시간 (예상)

```
프레임 처리 사이클 (30 FPS 기준):

┌─────────────────────────┬─────────┐
│ 단계                     │ 시간    │
├─────────────────────────┼─────────┤
│ 카메라 프레임 읽기       │  ~5ms   │
│ 이미지 rectify           │  ~3ms   │
│ Mediapipe 손 감지        │ ~15ms   │
│ 스테레오 매칭            │  ~1ms   │
│ 삼각측량 (21개 점)       │  ~2ms   │
│ 햅틱 로직 (거리 계산)    │  ~1ms   │
│ 화면 그리기              │  ~3ms   │
│ 키보드 입력 처리         │  ~1ms   │
├─────────────────────────┼─────────┤
│ 총 처리 시간             │ ~31ms   │
│ FPS                      │  ~32    │
└─────────────────────────┴─────────┘

실제 FPS: 25~35 (환경에 따라 변동)
```

### 메모리 사용량

```
- 프로그램 기본: ~100MB
- Mediapipe 모델: ~50MB
- 카메라 버퍼: ~10MB
- 그래프 데이터: <1MB

총: ~160MB (경량)
```

---

## 🚀 최적화 포인트

### 병목 구간
1. **Mediapipe 손 감지** (15ms) ← 가장 느림
2. **이미지 rectify** (3ms)
3. **화면 렌더링** (3ms)

### 개선 방법
```python
# 1. 해상도 다운스케일
camera:
  resolution:
    width: 320  # 640 → 320
    height: 240 # 480 → 240
# 예상 효과: Mediapipe 5ms 단축 → FPS 40+

# 2. 손 감지 스킵 프레임
every_n_frames = 2
if frame_count % every_n_frames == 0:
    hands_3d = tracker.process_frame(...)
# 예상 효과: CPU 사용률 50% 감소

# 3. 그래프 점 LOD (Level of Detail)
if moving_fast:
    num_points = 50
else:
    num_points = 100
# 예상 효과: 거리 계산 2배 속도
```

---

이 문서를 통해 시스템의 전체 작동 흐름을 이해하셨기를 바랍니다! 🎉
